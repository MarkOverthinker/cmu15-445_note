//===----------------------------------------------------------------------===//
//
//                         BusTub
//
// hash_table_test.cpp
//
// Identification: test/container/hash_table_test.cpp
//
// Copyright (c) 2015-2021, Carnegie Mellon University Database Group
//
//===----------------------------------------------------------------------===//

#include <thread>  // NOLINT
#include <vector>

#include "buffer/buffer_pool_manager_instance.h"
#include "common/logger.h"
#include "container/hash/extendible_hash_table.h"
#include "gtest/gtest.h"
#include "murmur3/MurmurHash3.h"

namespace bustub {

// NOLINTNEXTLINE

// NOLINTNEXTLINE
TEST(HashTableTest, SampleTest) {
  // auto *disk_manager = new DiskManager("test.db");
  // auto *bpm = new BufferPoolManagerInstance(50, disk_manager);
  // ExtendibleHashTable<int, int, IntComparator> ht("blah", bpm, IntComparator(), HashFunction<int>());
  // // insert a few values
  // for (int i = 0; i < 100; ++i) {
  // 	ExtendibleHashTable<int, int, IntComparator> ht("blah", bpm, IntComparator(), HashFunction<int>());
  // for (int i = 0; i < 1000; i++) {
  //   ht.Insert(nullptr, i, i);
  //   std::vector<int> res;
  //   ht.GetValue(nullptr, i, &res);
  //   EXPECT_EQ(1, res.size()) << "Failed to insert " << i << std::endl;
  //   EXPECT_EQ(i, res[0]);
  // }
  // ht.VerifyIntegrity();
  // // check if the inserted values are all there
  // for (int i = 0; i < 500; i++) {
  //    ht.Remove(nullptr, i, i);
  //   std::vector<int> res;
  //   EXPECT_FALSE(ht.GetValue(nullptr, i, &res));
  //   EXPECT_EQ(0, res.size()) << "Found non-existent key " << i << std::endl;
  // }
  // ht.VerifyIntegrity();

  // for (int i = 1000; i < 1500; i++) {
  //   EXPECT_TRUE(ht.Insert(nullptr, i, i));
  //   std::vector<int> res;
  //   EXPECT_TRUE(ht.GetValue(nullptr, i, &res));
  //   EXPECT_EQ(1, res.size()) << "Failed to insert " << i << std::endl;
  //   EXPECT_EQ(i, res[0]);
  // }

  // ht.VerifyIntegrity();

  // for (int i = 500; i < 1000; i++) {
  //   ht.Remove(nullptr, i, i);
  //   std::vector<int> res;
  //   EXPECT_FALSE(ht.GetValue(nullptr, i, &res));
  //   EXPECT_EQ(0, res.size()) << "Found non-existent key " << i << std::endl;
  // }

  // ht.VerifyIntegrity();

  // for (int i = 0; i < 500; i++) {
  //   EXPECT_TRUE(ht.Insert(nullptr, i, i));
  //   std::vector<int> res;
  //   EXPECT_TRUE(ht.GetValue(nullptr, i, &res));
  //   EXPECT_EQ(1, res.size()) << "Failed to insert " << i << std::endl;
  //   EXPECT_EQ(i, res[0]);
  // }

  // ht.VerifyIntegrity();

  // for (int i = 1000; i < 1500; i++) {
  //   ht.Remove(nullptr, i, i);
  //   std::vector<int> res;
  //   EXPECT_FALSE(ht.GetValue(nullptr, i, &res));
  //   EXPECT_EQ(0, res.size()) << "Found non-existent key " << i << std::endl;
  // }

  // ht.VerifyIntegrity();

  // for (int i = 0; i < 500; i++) {
  //   ht.Remove(nullptr, i, i);
  //   std::vector<int> res;
  //   EXPECT_FALSE(ht.GetValue(nullptr, i, &res));
  //   EXPECT_EQ(0, res.size()) << "Found non-existent key " << i << std::endl;
  // }

  // ht.VerifyIntegrity();

  // //  remove everything and make sure global depth < max_global_depth
  // for (int i = 0; i < 1500; i++) {
  //   ht.Remove(nullptr, i, i);
  // }

  // assert(ht.GetGlobalDepth() <= 1);
  // ht.VerifyIntegrity();

  // // insert one more value for each key
  // for (int i = 0; i < 1000; i++) {
  //   if (i == 0) {
  //     // duplicate values for the same key are not allowed
  //     EXPECT_FALSE(ht.Insert(nullptr, i, 2 * i));
  //   } else {
  //     EXPECT_TRUE(ht.Insert(nullptr, i, 2 * i));
  //   }
  //   EXPECT_FALSE(ht.Insert(nullptr, i, 2 * i));
  //   std::vector<int> res;
  //   ht.GetValue(nullptr, i, &res);
  //   if (i == 0) {
  //     // duplicate values for the same key are not allowed
  //     EXPECT_EQ(1, res.size());
  //     EXPECT_EQ(i, res[0]);
  //   } else {
  //     EXPECT_EQ(2, res.size());
  //     if (res[0] == i) {
  //       EXPECT_EQ(2 * i, res[1]);
  //     } else {
  //       EXPECT_EQ(2 * i, res[0]);
  //       EXPECT_EQ(i, res[1]);
  //     }
  //   }
  // }
  // ht.VerifyIntegrity();

  // // look for a key that does not exist
  // std::vector<int> res;
  // ht.GetValue(nullptr, 1000, &res);
  // EXPECT_EQ(0, res.size());
  // // delete some values
  // for (int i = 0; i < 1000; i++) {
  //   EXPECT_TRUE(ht.Remove(nullptr, i, i));
  //   ht.GetValue(nullptr, i, &res);
  //   if (i == 0) {
  //     // (0, 0) is the only pair with key 0
  //     EXPECT_EQ(0, res.size());
  //   } else {
  //     EXPECT_EQ(1, res.size());
  //     EXPECT_EQ(2 * i, res[0]);
  //   }
  // }
  // ht.VerifyIntegrity();

  // // delete all values
  // for (int i = 0; i < 1000; i++) {
  //   if (i == 0) {
  //     // (0, 0) has been deleted
  //     EXPECT_FALSE(ht.Remove(nullptr, i, 2 * i));
  //   } else {
  //     EXPECT_TRUE(ht.Remove(nullptr, i, 2 * i));
  //   }
  // }

  // }
  // disk_manager->ShutDown();
  // remove("test.db");
  // delete disk_manager;
  // delete bpm;

  // intergerconcurrency
  //   const int num_threads = 800;
  //   const int num_runs = 2;

  //   for (int run = 0; run < num_runs; run++) {
  //     auto *disk_manager = new DiskManager("test.db");
  //     auto *bpm = new BufferPoolManagerInstance(50, disk_manager);

  //     ExtendibleHashTable<int, int, IntComparator> *ht =
  //         new ExtendibleHashTable<int, int, IntComparator>("blah", bpm, IntComparator(), HashFunction<int>());
  //     std::vector<std::thread> threads(num_threads);

  //     for (int tid = 0; tid < num_threads; tid++) {
  //       threads[tid] = std::thread([&ht, tid]() {
  //         ht->Insert(nullptr, tid, tid);
  //         std::vector<int> res;
  //         ht->GetValue(nullptr, tid, &res);
  //         EXPECT_EQ(1, res.size()) << "Failed to insert " << tid << std::endl;
  //         EXPECT_EQ(tid, res[0]);
  //       });
  //     }

  //     for (int i = 0; i < num_threads; i++) {
  //       threads[i].join();
  //     }

  //     threads.clear();

  //     threads.resize(num_threads);
  //     for (int tid = 0; tid < num_threads; tid++) {
  //       threads[tid] = std::thread([&ht, tid]() {
  //         ht->Remove(nullptr, tid, tid);
  //         std::vector<int> res;
  //         ht->GetValue(nullptr, tid, &res);
  //         EXPECT_EQ(0, res.size());
  //       });
  //     }

  //     for (int i = 0; i < num_threads; i++) {
  //       threads[i].join();
  //     }

  //     threads.clear();

  //     threads.resize(num_threads);
  //     for (int tid = 0; tid < num_threads; tid++) {
  //       threads[tid] = std::thread([&ht, tid]() {
  //         // LOG_DEBUG("thread %d\n",tid);
  //         ht->Insert(nullptr, 1, tid);
  //         std::vector<int> res;
  //         ht->GetValue(nullptr, 1, &res);
  //         bool found = false;
  //         for (auto r : res) {
  //           if (r == tid) {
  //             found = true;
  //           }
  //         }
  //         EXPECT_EQ(true, found);
  //       });
  //     }

  //     for (int i = 0; i < num_threads; i++) {
  //       threads[i].join();
  //     }

  //     std::vector<int> res;
  //     ht->GetValue(nullptr, 1, &res);

  //     EXPECT_EQ(num_threads, res.size());

  //     delete ht;
  //     disk_manager->ShutDown();
  //     remove("test.db");
  //     delete disk_manager;
  //     delete bpm;
  //   }
  // }}

  // auto *disk_manager = new DiskManager("test.db");
  //   auto *bpm = new BufferPoolManagerInstance(50, disk_manager);
  //   ExtendibleHashTable<int, int, IntComparator> ht("blah", bpm, IntComparator(), HashFunction<int>());
  //   // insert a few values
  //   for (int i = 0; i < 100000; i++) {
  //     ht.Insert(nullptr, i, i);
  //     std::vector<int> res;
  //     ht.GetValue(nullptr, i, &res);
  //     EXPECT_EQ(1, res.size()) << "Failed to insert " << i << std::endl;
  //     EXPECT_EQ(i, res[0]);
  //   }
  //   ht.VerifyIntegrity();
  //   // check if the inserted values are all there
  //   for (int i = 0; i < 100000; i++) {
  //     std::vector<int> res;
  //     ht.GetValue(nullptr, i, &res);
  //     EXPECT_EQ(1, res.size()) << "Failed to keep " << i << std::endl;
  //     EXPECT_EQ(i, res[0]);
  //   }
  //   ht.VerifyIntegrity();

  //   // insert one more value for each key
  //   for (int i = 0; i < 100000; i++) {
  //     if (i == 0) {
  //       // duplicate values for the same key are not allowed
  //       EXPECT_FALSE(ht.Insert(nullptr, i, 2 * i));
  //     } else {
  //       EXPECT_TRUE(ht.Insert(nullptr, i, 2 * i));
  //     }
  //     EXPECT_FALSE(ht.Insert(nullptr, i, 2 * i));
  //     std::vector<int> res;
  //     ht.GetValue(nullptr, i, &res);
  //     if (i == 0) {
  //       // duplicate values for the same key are not allowed
  //       EXPECT_EQ(1, res.size());
  //       EXPECT_EQ(i, res[0]);
  //     } else {
  //       EXPECT_EQ(2, res.size());
  //       if (res[0] == i) {
  //         EXPECT_EQ(2 * i, res[1]);
  //       } else {
  //         EXPECT_EQ(2 * i, res[0]);
  //         EXPECT_EQ(i, res[1]);
  //       }
  //     }
  //   }
  //   ht.VerifyIntegrity();

  //   // look for a key that does not exist
  //   std::vector<int> res;
  //   ht.GetValue(nullptr, 210000, &res);
  //   EXPECT_EQ(0, res.size());
  //   // delete some values
  //   for (int i = 0; i < 100000; i++) {
  //     EXPECT_TRUE(ht.Remove(nullptr, i, i));
  //     ht.GetValue(nullptr, i, &res);
  //     if (i == 0) {
  //       // (0, 0) is the only pair with key 0
  //       EXPECT_EQ(0, res.size());
  //     } else {
  //       EXPECT_EQ(1, res.size());
  //       EXPECT_EQ(2 * i, res[0]);
  //     }
  //   }
  //   ht.VerifyIntegrity();

  //   // delete all values
  //   for (int i = 0; i < 100000; i++) {
  //     if (i == 0) {
  //       // (0, 0) has been deleted
  //       EXPECT_FALSE(ht.Remove(nullptr, i, 2 * i));
  //     } else {
  //       EXPECT_TRUE(ht.Remove(nullptr, i, 2 * i));
  //     }
  //   }

  //   ht.VerifyIntegrity();

  //   disk_manager->ShutDown();
  //   remove("test.db");
  //   delete disk_manager;
  //   delete bpm;
  // }
  const int num_threads = 50;
  const int num_runs = 10;

  for (int run = 0; run < num_runs; run++) {
    auto *disk_manager = new DiskManager("test.db");
    auto *bpm = new BufferPoolManagerInstance(50, disk_manager);
    ExtendibleHashTable<int, int, IntComparator> *ht =
        new ExtendibleHashTable<int, int, IntComparator>("blah", bpm, IntComparator(), HashFunction<int>());
    std::vector<std::thread> threads(num_threads);

    for (int tid = 0; tid < num_threads; tid++) {
      threads[tid] = std::thread([&ht, tid]() {
        for (int i = num_threads * tid; i < num_threads * (tid + 1); i++) {
          ht->Insert(nullptr, i, i);
          std::vector<int> res;
          ht->GetValue(nullptr, i, &res);
          EXPECT_EQ(1, res.size()) << "Failed to insert " << i << std::endl;
          EXPECT_EQ(i, res[0]);
        }
      });
    }

    for (int i = 0; i < num_threads; i++) {
      threads[i].join();
    }

    threads.clear();

    threads.resize(num_threads);
    for (int tid = 0; tid < num_threads; tid++) {
      threads[tid] = std::thread([&ht, tid]() {
        for (int i = num_threads * tid; i < num_threads * (tid + 1); i++) {
          std::vector<int> res;
          ht->GetValue(nullptr, i, &res);
          EXPECT_EQ(1, res.size()) << "Failed to insert " << i << std::endl;
          EXPECT_EQ(i, res[0]);
        }
      });
    }

    for (int i = 0; i < num_threads; i++) {
      threads[i].join();
    }

    threads.clear();

    threads.resize(num_threads);
    for (int tid = 0; tid < num_threads; tid++) {
      threads[tid] = std::thread([&ht, tid]() {
        for (int i = num_threads * tid; i < num_threads * (tid + 1); i++) {
          ht->Insert(nullptr, i, i);
          std::vector<int> res;
          ht->GetValue(nullptr, i, &res);
          EXPECT_EQ(1, res.size()) << "Failed to insert " << i << std::endl;
        }
        for (int i = num_threads * tid; i < num_threads * (tid + 1); i++) {
          ht->Remove(nullptr, i, i);
          std::vector<int> res;
          ht->GetValue(nullptr, i, &res);
          EXPECT_EQ(0, res.size()) << "Failed to insert " << tid << std::endl;
        }
      });
    }

    for (int i = 0; i < num_threads; i++) {
      threads[i].join();
    }

    threads.clear();
    delete ht;
    disk_manager->ShutDown();
    remove("test.db");
    delete disk_manager;
    delete bpm;
  }
}
}  // namespace bustub

// auto *disk_manager = new DiskManager("test.db");
//   // We should be able to do anything with strictly 3 pages allocated.
//   auto *bpm = new BufferPoolManagerInstance(3, disk_manager);
//   ExtendibleHashTable<int, int, IntComparator> ht("blah", bpm, IntComparator(), HashFunction<int>());

//   int num_values_to_insert = 200000;
//   // insert a few values
//   for (int i = 0; i < num_values_to_insert; i++) {
//     ht.Insert(nullptr, i, i);
//     std::vector<int> res;
//     ht.GetValue(nullptr, i, &res);
//     EXPECT_EQ(1, res.size()) << "Failed to insert " << i << std::endl;
//     EXPECT_EQ(i, res[0]);
//   }

//   // check if the inserted values are all there
//   for (int i = 0; i < num_values_to_insert; i++) {
//     std::vector<int> res;
//     ht.GetValue(nullptr, i, &res);
//     EXPECT_EQ(1, res.size()) << "Failed to keep " << i << std::endl;
//     EXPECT_EQ(i, res[0]);
//   }

//   // At least one page needs to be swapped
//   bool are_buffer_pages_correct = disk_manager->GetNumWrites() >= 0;
//   EXPECT_TRUE(are_buffer_pages_correct) << "Incorrect usage of buffer pool";

//   disk_manager->ShutDown();
//   remove("test.db");
//   delete disk_manager;
//   delete bpm;
// }
// }
